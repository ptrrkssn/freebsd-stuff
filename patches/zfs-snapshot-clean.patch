--- cddl/contrib/opensolaris/cmd/zfs/zfs_main.c.RELEASE	2020-02-29 22:21:01.102091000 +0100
+++ cddl/contrib/opensolaris/cmd/zfs/zfs_main.c	2020-03-20 22:50:59.180653000 +0100
@@ -88,6 +88,7 @@
 static int zfs_do_clone(int argc, char **argv);
 static int zfs_do_create(int argc, char **argv);
 static int zfs_do_destroy(int argc, char **argv);
+static int zfs_do_clean(int argc, char **argv);
 static int zfs_do_get(int argc, char **argv);
 static int zfs_do_inherit(int argc, char **argv);
 static int zfs_do_list(int argc, char **argv);
@@ -138,6 +139,7 @@
 	HELP_CLONE,
 	HELP_CREATE,
 	HELP_DESTROY,
+	HELP_CLEAN,
 	HELP_GET,
 	HELP_INHERIT,
 	HELP_UPGRADE,
@@ -186,6 +188,7 @@
 static zfs_command_t command_table[] = {
 	{ "create",	zfs_do_create,		HELP_CREATE		},
 	{ "destroy",	zfs_do_destroy,		HELP_DESTROY		},
+	{ "clean",	zfs_do_clean,		HELP_CLEAN		},
 	{ NULL },
 	{ "snapshot",	zfs_do_snapshot,	HELP_SNAPSHOT		},
 	{ "rollback",	zfs_do_rollback,	HELP_ROLLBACK		},
@@ -247,6 +250,9 @@
 		    "\tdestroy [-dnpRrv] "
 		    "<filesystem|volume>@<snap>[%<snap>][,...]\n"
 		    "\tdestroy <filesystem|volume>#<bookmark>\n"));
+	case HELP_CLEAN:
+		return (gettext("\tclean [-iyvndfpre] [-V level] [-a age] [-E prop] [-T time] "
+				"<filesystem|volume> ...\n"));
 	case HELP_GET:
 		return (gettext("\tget [-rHp] [-d max] "
 		    "[-o \"all\" | field[,...]]\n"
@@ -298,8 +304,9 @@
 	case HELP_SHARE:
 		return (gettext("\tshare <-a | filesystem>\n"));
 	case HELP_SNAPSHOT:
-		return (gettext("\tsnapshot|snap [-r] [-o property=value] ... "
-		    "<filesystem|volume>@<snap> ...\n"));
+		return (gettext("\tsnapshot|snap [-n] [-v] [-r] "
+		    "[-m minfree] [-E prop] [-e time] [-T time] [-o property=value]... "
+		    "... <filesystem|volume>@<snap> ...\n"));
 	case HELP_UNMOUNT:
 		return (gettext("\tunmount|umount [-f] "
 		    "<-a | filesystem|mountpoint>\n"));
@@ -997,6 +1004,11 @@
 	nvlist_t	*cb_nvl;
 	nvlist_t	*cb_batchedsnaps;
 
+	/* clean verbosity/check flags */
+  	int		cb_clean;
+	time_t          cb_max_age;
+	char            *cb_expires_prop;	
+  
 	/* first snap in contiguous run */
 	char		*cb_firstsnap;
 	/* previous snap in contiguous run */
@@ -1006,6 +1018,17 @@
 	char		*cb_bookmark;
 } destroy_cbdata_t;
 
+
+
+static void
+sigalrm_handler(int sig) {
+	static char msg[] = "\n*** ABORTED DUE TO TIMEOUT ***\n";
+	
+	(void) write(2, msg, sizeof(msg)-1);
+	_exit(1);
+}
+
+
 /*
  * Check for any dependents based on the '-r' or '-R' flags.
  */
@@ -1072,7 +1095,12 @@
 	destroy_cbdata_t *cb = data;
 	const char *name = zfs_get_name(zhp);
 
-	if (cb->cb_verbose) {
+	if (cb->cb_clean) {
+	  	if (cb->cb_parsable)
+		  	(void) printf("%s%s\n",
+				      cb->cb_clean > 1 ? "- " : "",
+				      name);
+	} else if (cb->cb_verbose) {
 		if (cb->cb_parsable) {
 			(void) printf("destroy\t%s\n", name);
 		} else if (cb->cb_dryrun) {
@@ -1107,7 +1135,7 @@
 	if (zfs_get_type(zhp) == ZFS_TYPE_SNAPSHOT) {
 		fnvlist_add_boolean(cb->cb_batchedsnaps, name);
 	} else {
-		int error = zfs_destroy_snaps_nvl(g_zfs,
+	  	int error = zfs_destroy_snaps_nvl(g_zfs,
 		    cb->cb_batchedsnaps, B_FALSE);
 		fnvlist_free(cb->cb_batchedsnaps);
 		cb->cb_batchedsnaps = fnvlist_alloc();
@@ -1140,7 +1168,12 @@
 		cb->cb_prevsnap = strdup(name);
 		if (cb->cb_firstsnap == NULL || cb->cb_prevsnap == NULL)
 			nomem();
-		if (cb->cb_verbose) {
+		if (cb->cb_clean) {
+		  	if (cb->cb_parsable)
+				(void) printf("%s%s\n",
+					      cb->cb_clean > 1 ? "- " : "",
+					      name);
+		} else if (cb->cb_verbose) {
 			if (cb->cb_parsable) {
 				(void) printf("destroy\t%s\n", name);
 			} else if (cb->cb_dryrun) {
@@ -1151,7 +1184,12 @@
 				    name);
 			}
 		}
-	} else if (cb->cb_firstsnap != NULL) {
+		zfs_close(zhp);
+		return (err);
+	}
+
+ Out:
+	if (cb->cb_firstsnap != NULL) {
 		/* end of this range */
 		uint64_t used = 0;
 		err = lzc_snaprange_space(cb->cb_firstsnap,
@@ -1194,35 +1232,121 @@
 	destroy_cbdata_t *cb = arg;
 	int err = 0;
 
+	if (zfs_get_type(zhp) == ZFS_TYPE_SNAPSHOT) {
+		if (cb->cb_max_age) {
+			time_t created;
+	    
+			if ((created = zfs_prop_get_int(zhp, ZFS_PROP_CREATION)) >= cb->cb_max_age) {
+				if (cb->cb_clean > 4)
+					printf(gettext("skipping destroy of '%s'"
+					    ": creation too new (%llu >= %llu)\n"),
+					    zfs_get_name(zhp),
+					    (unsigned long long) created,
+					    (unsigned long long) cb->cb_max_age);
+				zfs_close(zhp);
+				return (0);
+			}
+		}
+	  
+		if (cb->cb_expires_prop) {
+			time_t now, expires;
+			nvlist_t *userprops = zfs_get_user_props(zhp);
+			nvlist_t *propval = NULL;
+			char *strval = NULL;
+			
+			time(&now);
+			(void) nvlist_lookup_nvlist(userprops, cb->cb_expires_prop, &propval);
+			
+			if (!propval || nvlist_lookup_string(propval, ZPROP_VALUE, &strval) != 0) {
+				if (cb->cb_clean > 4)
+					printf(gettext("skipping destroy of '%s'"
+					    ": expire property (%s) not set or invalid\n"),
+					    zfs_get_name(zhp),
+					    cb->cb_expires_prop);
+				zfs_close(zhp);
+				return (0);
+			}
+			
+			if (sscanf(strval, "%lu", &expires) == 1 && now < expires) {
+				if (cb->cb_clean > 4)
+					printf(gettext("skipping destroy of '%s'"
+					    ": not expired (%ld < %ld)\n"),
+					    zfs_get_name(zhp),
+					    now, expires);
+				zfs_close(zhp);
+				return (0);
+			}
+		}
+	}
+	
 	/* Check for clones. */
 	if (!cb->cb_doclones && !cb->cb_defer_destroy) {
 		cb->cb_target = zhp;
 		cb->cb_first = B_TRUE;
 		err = zfs_iter_dependents(zhp, B_TRUE,
 		    destroy_check_dependent, cb);
+		if (err)
+			goto Out;
 	}
+	if (nvlist_add_boolean(cb->cb_nvl, zfs_get_name(zhp)))
+		nomem();
 
-	if (err == 0) {
-		if (nvlist_add_boolean(cb->cb_nvl, zfs_get_name(zhp)))
-			nomem();
-	}
+ Out:
 	zfs_close(zhp);
 	return (err);
 }
 
+static void
+spin(void) {
+  	static int p = 0;
+	static char dials[] = "|/-\\";
+	static time_t last = 0;
+	time_t now;
+	
+	if (isatty(fileno(stderr))) {
+	  	time(&now);
+		if (now != last) {
+		  	putc(dials[p], stderr);
+			putc('\b', stderr);
+			p = (p+1)&3;
+			last = now;
+		}
+	}
+}
+
+
 static int
 gather_snapshots(zfs_handle_t *zhp, void *arg)
 {
 	destroy_cbdata_t *cb = arg;
 	int err = 0;
-
+	size_t ns, ons;
+	
+	if (cb->cb_clean > 3) {
+		static int ns = 0;
+		printf("%s: Scanning [%d]\n", zfs_get_name(zhp), ++ns);
+	} else if (!cb->cb_verbose)
+		spin();
+
+	if (cb->cb_clean > 1)
+	  	ons = fnvlist_num_pairs(cb->cb_nvl);
+		
 	err = zfs_iter_snapspec(zhp, cb->cb_snapspec, snapshot_to_nvl_cb, cb);
+
+	if (cb->cb_clean > 1) {
+	  	ns = fnvlist_num_pairs(cb->cb_nvl);
+	  	printf("%-30s\t: %6ld snapshots to delete [+%ld]\n",
+		       zfs_get_name(zhp),
+		       ns, ns-ons);
+	}
+	
 	if (err == ENOENT)
 		err = 0;
 	if (err != 0)
 		goto out;
 
-	if (cb->cb_verbose) {
+	
+	if (cb->cb_verbose || cb->cb_clean) {
 		err = destroy_print_snapshots(zhp, cb);
 		if (err != 0)
 			goto out;
@@ -1266,6 +1390,164 @@
 }
 
 static int
+prompt_yesno(const char *fmt,
+	     ...) {
+	va_list ap;
+	char *cp, buf[32];
+	int t = 0;
+
+	fflush(stdout);
+	
+	/* Assume 'no' if no TTY to prompt user */
+	if (!isatty(fileno(stderr))) {
+		va_start(ap, fmt);
+		vfprintf(stderr, fmt, ap);
+		va_end(ap);
+		fprintf(stderr, "no\n");
+		return 0;
+	}
+  
+	while (t++ < 3) {
+	  	if (t > 1)
+		  	fprintf(stderr,
+				"*** Please answer 'yes' or 'no'\n");
+		
+		va_start(ap, fmt);
+		vfprintf(stderr, fmt, ap);
+		va_end(ap);
+    
+		if (fgets(buf, sizeof(buf), stdin) == NULL) {
+			/* Assume 'no' if we get EOF */
+		  fputs("no\n", stderr);
+		  return 0;
+		}
+    
+		for (cp = buf+strlen(buf)-1; cp >= buf && isspace(*cp); --cp)
+			;
+		*++cp = '\0';
+		for (cp = buf; isspace(*cp); ++cp)
+			;
+		if (strcasecmp(cp, "yes") == 0)
+			return 1;
+		else if (!*cp ||
+			 strcasecmp(cp, "no") == 0 ||
+			 strcasecmp(cp, "n") == 0)
+	       		return 0;
+	}
+
+	fprintf(stderr, "*** Assuming 'no'\n");
+	return 0;
+}
+
+
+#define STR2TIME_BEFORE   -1
+#define STR2TIME_RELATIVE  0
+#define STR2TIME_AFTER     1
+
+static int
+str2time(const char *str,
+	 time_t *rtp,
+	 int absolute) {
+  	char pfx = 0;
+	int rc;
+	time_t now, t;
+	int t_year, t_mon, t_day, t_hour, t_min, t_sec;
+	struct tm *tp;
+
+	
+	if (!str || !*str)
+		return 0;
+
+	time(&now);
+	
+	while (isspace(*str))
+		++str;
+
+	t_year = t_mon = t_day = t_hour = t_min = t_sec = 0;
+
+	if ((rc = sscanf(str, "%d-%d-%d %d:%d:%d",
+			 &t_year, &t_mon, &t_day,
+			 &t_hour, &t_min, &t_sec)) >= 5 || rc == 3) {
+	  /* Absolute date+time */
+	  tp = localtime(&now);
+	  if (!tp)
+	  	return -1;
+
+	  if (t_year >= 1900)
+	  	tp->tm_year = t_year-1900;
+	  else
+	  	tp->tm_year = t_year+100;
+
+	  tp->tm_mon  = t_mon-1;
+	  tp->tm_mday = t_day;
+	  tp->tm_hour = t_hour;
+	  tp->tm_min  = t_min;
+	  tp->tm_sec  = t_sec;;
+	  
+	  t = mktime(tp);
+	  if (t == (time_t) -1)
+	    	return -1;
+
+	  if (!absolute)
+	    t -= now;
+	  
+	  *rtp = t;
+	  return 1;
+    
+	} else if ((rc = sscanf(str, "%d:%d:%d",
+				&t_hour, &t_min, &t_sec)) >= 2) {
+	  	t = t_sec + (t_min*60) + (t_hour*3600);
+		
+		if (absolute)
+		  t += (absolute * now);
+		*rtp = t;
+		return 1;
+    
+	} else if ((rc = sscanf(str, "%lu%c", &t, &pfx)) >= 1) {
+	  	/* Offset from now */
+    
+		switch (pfx) {
+		case 's':
+		  	break;
+		case 'm':
+		  	t *= 60;
+			break;
+		case 'h':
+		  	t *= 60*60;
+			break;
+		case 'D':
+		  	t *= 24*60*60;
+			break;
+		case 'W':
+		  	t *= 7*24*60*60;
+			break;
+		case 'M':
+		  	t *= 30*24*60*60;
+			break;
+		case 'Y':
+		  	t *= 365*24*60*60;
+			break;
+		default:
+		  	return -1;
+		}
+
+		switch (absolute) {
+		case STR2TIME_BEFORE:
+		  *rtp = now - t;
+		  break;
+		case STR2TIME_AFTER:
+		  *rtp = now + t;
+		  break;
+		case STR2TIME_RELATIVE:
+		  *rtp = t;
+		}
+		return 1;
+	}
+	
+	return (rc == 0 ? 0 : -1);
+}
+
+static int
 zfs_do_destroy(int argc, char **argv)
 {
 	destroy_cbdata_t cb = { 0 };
@@ -1496,6 +1778,235 @@
 	return (rv);
 }
 
+
+static char *
+strdupcat(const char *s1, ...) {
+  char *res, *s;
+  size_t len;
+  va_list ap;
+
+  va_start(ap, s1);
+  len = strlen(s1);
+  while ((s = va_arg(ap, char *)) != NULL)
+    len += strlen(s);
+  va_end(ap);
+
+  res = malloc(len+1);
+  if (!res)
+    return NULL;
+  strcpy(res, s1);
+  
+  va_start(ap, s1);
+  while ((s = va_arg(ap, char *)) != NULL)
+    strcat(res, s);
+  va_end(ap);
+
+  return res;
+}
+
+/*
+ * Limited variant of "destroy" that _only_ does snapshots, and allows
+ * multiple datasets listed on the command line.
+ */
+static int
+zfs_do_clean(int argc, char **argv)
+{
+	destroy_cbdata_t cb = { 0 };
+	int rv = 0;
+	int err = 0;
+	int c;
+	zfs_handle_t *zhp = NULL;
+	char *at, *pound;
+	unsigned long maxage;
+	char pfx;
+	boolean_t f_quack = B_FALSE;
+	boolean_t f_yes = B_FALSE;
+	time_t now, timeout = 0;
+	char *expires_prop = "se.liu.it:expires";
+	boolean_t check_expire = 0;
+	size_t nsnaps;
+
+	cb.cb_clean = 1;
+	
+	/* check options */
+	while ((c = getopt(argc, argv, "iyvpndfrV:A:E:eT:")) != -1) {
+		switch (c) {
+		case 'i':
+			f_quack = B_TRUE;
+			break;
+		case 'y':
+			f_yes = B_TRUE;
+			break;
+		case 'v':
+			cb.cb_verbose = B_TRUE;
+			break;
+		case 'p':
+			cb.cb_verbose = B_TRUE;
+			cb.cb_parsable = B_TRUE;
+			break;
+		case 'n':
+			cb.cb_dryrun = B_TRUE;
+			break;
+		case 'd':
+			cb.cb_defer_destroy = B_TRUE;
+			break;
+		case 'f':
+			cb.cb_force = B_TRUE;
+			break;
+		case 'r':
+			cb.cb_recurse = B_TRUE;
+			break;
+		case 'V':
+			if (!optarg || sscanf(optarg, "%d", &cb.cb_clean) != 1) {
+				(void) fprintf(stderr,
+				    gettext("invalid verbosity level '%s'"), optarg ? optarg : "");
+				goto OUT;
+			}
+			cb.cb_clean++;
+			break;
+		case 'E':
+		  	expires_prop = strdup(optarg);
+			check_expire = B_TRUE;
+			break;
+		case 'e':
+		  	check_expire = B_TRUE;
+			break;
+		case 'a':
+		  	if (str2time(optarg, &cb.cb_max_age, STR2TIME_BEFORE) < 1) {
+				(void) fprintf(stderr,
+				    gettext("invalid max age '%s'"), optarg ? optarg : "");
+				goto OUT;
+			}
+			fprintf(stderr, "*** MAXAGE: %s", ctime(&cb.cb_max_age));
+			break;
+		case 'T':
+			if (str2time(optarg, &timeout, STR2TIME_RELATIVE) < 1 || timeout < 0) {
+				(void) fprintf(stderr,
+			            gettext("invalid timeout '%s'"), optarg ? optarg : "");
+				goto OUT;
+			}
+			fprintf(stderr, "*** TIMEOUT: %ds\n", timeout);
+			break;
+		case '?':
+		default:
+			(void) fprintf(stderr, gettext("invalid option '%c'\n"),
+			    optopt);
+			usage(B_FALSE);
+		}
+	}
+
+	if (check_expire)
+	  	cb.cb_expires_prop = strdup(expires_prop);
+	
+	if (timeout) {
+		signal(SIGALRM, sigalrm_handler);
+		alarm(timeout);
+	}
+	
+	argc -= optind;
+	argv += optind;
+
+	/* check number of arguments */
+	if (argc == 0) {
+		(void) fprintf(stderr, gettext("missing dataset argument\n"));
+		usage(B_FALSE);
+	}
+
+	/* Build the list of snaps to destroy in cb_nvl. */
+	cb.cb_nvl = fnvlist_alloc();
+	  
+	while (argc > 0) {
+		char *fsname = NULL;
+		
+		pound = strchr(argv[0], '#');
+		if (pound) {
+		  	(void) fprintf(stderr,
+			    "clean is not supported with bookmarks\n");
+			return (-1);
+		}
+
+		/* Make sure we always have a snapshot specifier (@<something>) */
+		if (strchr(argv[0], '@'))
+			fsname = strdupcat(argv[0], NULL);
+		else
+			fsname = strdupcat(argv[0], "@", "%", NULL);
+	  
+		at = strchr(fsname, '@');
+		*at = '\0';
+	    
+		zhp = zfs_open(g_zfs, fsname,
+			       ZFS_TYPE_FILESYSTEM | ZFS_TYPE_VOLUME);
+		if (zhp == NULL)
+			return (1);
+	  
+		cb.cb_snapspec = at + 1;
+
+		if (gather_snapshots(zfs_handle_dup(zhp), &cb) != 0 || cb.cb_error) {
+			rv = 1;
+			goto OUT;
+		}
+
+		zfs_close(zhp);
+		zhp = NULL;
+
+		--argc;
+		++argv;
+	}
+	
+	/* Get the number of snapshots to delete */
+	nsnaps = (cb.cb_nvl ? fnvlist_num_pairs(cb.cb_nvl) : -1);
+	  
+	if (cb.cb_clean > 2)
+	  	printf("Total snapshots to delete: %ld\n",
+		       nsnaps);
+	  
+	if (nsnaps == 0)
+	  	goto OUT;
+	  
+	if (!cb.cb_dryrun) {
+	  	if (!f_yes && (f_quack || nsnaps > 1)) {
+		  	int rc;
+			char buf[16];
+	      
+			zfs_nicenum(cb.cb_snapused, buf, sizeof (buf));
+			rc = prompt_yesno("Destroy %d snapshot%s (%sB) [no]? ",
+					  nsnaps,
+					  nsnaps == 1 ? "" : "s",
+					  buf);
+			if (rc != B_TRUE) {
+			  	rv = 1;
+				goto OUT;
+			}
+		}
+		
+		if (err == 0) {
+		  	if (cb.cb_clean > 1)
+			  	printf("Destroying %ld snapshot%s%s\n",
+				       nsnaps,
+				       nsnaps == 1 ? "" : "s",
+				       cb.cb_defer_destroy ? " (deferred)" : "");
+	      
+			err = zfs_destroy_snaps_nvl(g_zfs, cb.cb_nvl,
+						    cb.cb_defer_destroy);
+			if (err != 0) {
+			  	rv = 1;
+				goto OUT;
+			}
+		}
+	}
+	
+
+ OUT:
+	if (cb.cb_batchedsnaps)
+		fnvlist_free(cb.cb_batchedsnaps);
+	if (cb.cb_nvl)
+		fnvlist_free(cb.cb_nvl);
+	if (zhp != NULL)
+		zfs_close(zhp);
+	
+	return (rv);
+}
+
 static boolean_t
 is_recvd_column(zprop_get_cbdata_t *cbp)
 {
@@ -3677,6 +4188,9 @@
 	nvlist_t *sd_nvl;
 	boolean_t sd_recursive;
 	const char *sd_snapname;
+	uint64_t sd_min_avail;
+	boolean_t sd_verbose;
+	boolean_t sd_no_update;
 } snap_cbdata_t;
 
 static int
@@ -3686,18 +4200,31 @@
 	char *name;
 	int rv = 0;
 	int error;
-
+	uint64_t avail;
+	time_t created;
+     
 	if (sd->sd_recursive &&
 	    zfs_prop_get_int(zhp, ZFS_PROP_INCONSISTENT) != 0) {
 		zfs_close(zhp);
 		return (0);
 	}
 
-	error = asprintf(&name, "%s@%s", zfs_get_name(zhp), sd->sd_snapname);
-	if (error == -1)
-		nomem();
-	fnvlist_add_boolean(sd->sd_nvl, name);
-	free(name);
+	if (sd->sd_min_avail && (avail = zfs_prop_get_int(zhp, ZFS_PROP_AVAILABLE)) < sd->sd_min_avail) {
+	  if (sd->sd_verbose) {
+	    fprintf(stderr,
+		    gettext("skipping snapshot of '%s'"
+			    ": avail too low (%llu < %llu)\n"),
+		    zfs_get_name(zhp),
+		    (unsigned long long) avail,
+		    (unsigned long long) sd->sd_min_avail);
+	  }
+	} else {
+		error = asprintf(&name, "%s@%s", zfs_get_name(zhp), sd->sd_snapname);
+		if (error == -1)
+			nomem();
+		fnvlist_add_boolean(sd->sd_nvl, name);
+		free(name);
+	}
 
 	if (sd->sd_recursive)
 		rv = zfs_iter_filesystems(zhp, zfs_snapshot_cb, sd);
@@ -3705,8 +4232,10 @@
 	return (rv);
 }
 
+#define DEFAULT_EXPIRE_PROP "se.liu.it:expires"
+
 /*
- * zfs snapshot [-r] [-o prop=value] ... <fs@snap>
+ * zfs snapshot [-v] [-n] [-r] [-m minfree] [-e prop] [-a age] [-o prop=value] ... <fs@snap>
  *
  * Creates a snapshot with the given name.  While functionally equivalent to
  * 'zfs create', it is a separate command to differentiate intent.
@@ -3719,23 +4248,90 @@
 	nvlist_t *props;
 	snap_cbdata_t sd = { 0 };
 	boolean_t multiple_snaps = B_FALSE;
+	char pfx, buf[64];
+	unsigned long avail = 0;
+	time_t now, timeout = 0;
+	size_t nsnaps;
+	char *expire_prop = NULL;
+	time_t expire_time = 0;
+	char *strval;
 
+	
 	if (nvlist_alloc(&props, NV_UNIQUE_NAME, 0) != 0)
 		nomem();
 	if (nvlist_alloc(&sd.sd_nvl, NV_UNIQUE_NAME, 0) != 0)
 		nomem();
 
+	sd.sd_min_avail = 0;
+	sd.sd_verbose = 0;
+	sd.sd_no_update = 0;
+	
 	/* check options */
-	while ((c = getopt(argc, argv, "ro:")) != -1) {
+	while ((c = getopt(argc, argv, "nvro:m:t:T:e:E:")) != -1) {
 		switch (c) {
 		case 'o':
 			if (parseprop(props, optarg) != 0)
 				return (1);
 			break;
+		case 'n':
+			sd.sd_no_update = 1;
+			break;
+		case 'v':
+			sd.sd_verbose = 1;
+			break;
 		case 'r':
 			sd.sd_recursive = B_TRUE;
 			multiple_snaps = B_TRUE;
 			break;
+		case 'm':
+			pfx = 0;
+			if (!optarg ||
+			    sscanf(optarg, "%lu%c",
+			    &avail, &pfx) < 1) {
+				(void) fprintf(stderr,
+				    gettext("invalid minfree '%s'"), optarg);
+				goto usage;
+			}
+			sd.sd_min_avail = avail;
+			switch (toupper(pfx)) {
+			case 'K':
+				sd.sd_min_avail *= 1000;
+				break;
+			case 'M':
+				sd.sd_min_avail *= 1000000;
+				break;
+			case 'G':
+				sd.sd_min_avail *= 1000000000;
+				break;
+			case 'T':
+				sd.sd_min_avail *= 1000000000000;
+				break;
+			default:
+				(void) fprintf(stderr,
+				    gettext("invalid minfree suffix '%s'"),
+				    optarg);
+				goto usage;
+			}
+			break;
+		case 'T':
+		  	if (str2time(optarg, &timeout, STR2TIME_RELATIVE) < 1 || timeout < 0) {
+			  	(void) fprintf(stderr,
+				    gettext("invalid timeout '%s'"), optarg ? optarg : "");
+				goto usage;
+			}
+			fprintf(stderr, "*** TIMEOUT: %ds\n", timeout);
+			break;
+		case 'E':
+		  	expire_prop = strdup(optarg);
+			break;
+
+		case 'e':
+		  	if (str2time(optarg, &expire_time, STR2TIME_AFTER) < 1) {
+			  	(void) fprintf(stderr,
+				    gettext("invalid expire age '%s'"), optarg ? optarg : "");
+				goto usage;
+			}
+			break;
 		case '?':
 			(void) fprintf(stderr, gettext("invalid option '%c'\n"),
 			    optopt);
@@ -3743,6 +4339,31 @@
 		}
 	}
 
+	if (expire_time) {
+		char *ep;
+		
+		if (!expire_prop)
+			expire_prop = strdup(DEFAULT_EXPIRE_PROP);
+		
+		fprintf(stderr, "*** EXPIRES: %s", ctime(&expire_time));
+		snprintf(buf, sizeof(buf), "%lu", expire_time);
+		
+		while ((ep = strsep(&expire_prop, ",")) != NULL) {
+			if (nvlist_lookup_string(props, ep, &strval) == 0) {
+				(void) fprintf(stderr, gettext("expire property '%s' "
+				    "specified multiple times\n"), ep);
+				goto usage;
+			}
+			if (nvlist_add_string(props, ep, buf) != 0)
+				nomem();
+		}
+	}
+
+	if (timeout) {
+		signal(SIGALRM, sigalrm_handler);
+		alarm(timeout);
+	}
+	
 	argc -= optind;
 	argv += optind;
 
@@ -3771,9 +4392,20 @@
 			goto usage;
 	}
 
-	ret = zfs_snapshot_nvl(g_zfs, sd.sd_nvl, props);
+	ret = 0;
+	nsnaps = fnvlist_num_pairs(sd.sd_nvl);
+	  
+	if (!sd.sd_no_update && nsnaps > 0)
+		ret = zfs_snapshot_nvl(g_zfs, sd.sd_nvl, props);
+
 	nvlist_free(sd.sd_nvl);
 	nvlist_free(props);
+	
+	if (ret == 0 && sd.sd_verbose)
+		printf("Snapshots %screated: %ld\n",
+		       sd.sd_no_update ? "(NOT) " : "",
+		       nsnaps);
+	
 	if (ret != 0 && multiple_snaps)
 		(void) fprintf(stderr, gettext("no snapshots were created\n"));
 	return (ret != 0);
