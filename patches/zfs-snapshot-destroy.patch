This patch adds a number of new command line switches to 'zfs snapshot' and 'zfs destroy'
that makes it possible to handle large number of snapshots in a more sane way.


EXAMPLE USAGE:

  # Create snapshots (skip FS with less than 200M free space) and set an expire date in 48 hours
  EXPIRES="`date -d 'now+48hours' '+%s'`"
  NOW="`date +'%Y-%m-%d.%H:%M:%S'`
  zfs snap -r -m 200M -o "se.liu.it:expires=${EXPIRES}" "DATA@auto-${NOW}"

  # Destroy (and be verbose) all expired snapshots (give up if it takes more than 4 hours)
  zfs destroy -r -v -e "se.liu.it:expires" -T 4h "DATA@auto-%"

  # Destroy (and be verbose) all snapshots older than 2 weeks (give up if it takes more than 4 hours)
  zfs destroy -r -v -a 2W -T 4h 'DATA@auto-%'


NEW COMMAND LINE OPTIONS:

  zfs snapshot
    -v		Be more verbose
    -T time	Set a time limit and abort (recursive snapshots) if it is exceeded
    -m minfree	Skip taking snapshots on filesystems with less than <minfree> space available

  zfs destroy
    -v		Be more verbose
    -V level	Set the verbosity level
    -T time	Set a time limit and abort (recursive destroys) if
       		it is exceeded
    -a maxage	Only delete snapshots older than <maxage>
    -e prop	Lookup up expire time (seconds) in user property <prop>
       		and delete expired snapshots
Not fully implemented yet:		
    -i		Interactive - ask for permissions before destroying
    -y		Answer "yes" to any questions

- Peter Eriksson <pen@lysator.liu.se>, 2020-03-19


		--- cddl/contrib/opensolaris/cmd/zfs/zfs_main.c.RELEASE	2020-02-29 22:21:01.102091000 +0100
+++ cddl/contrib/opensolaris/cmd/zfs/zfs_main.c	2020-03-19 14:01:59.281621000 +0100
@@ -243,8 +243,8 @@
 		    "\tcreate [-ps] [-b blocksize] [-o property=value] ... "
 		    "-V <size> <volume>\n"));
 	case HELP_DESTROY:
-		return (gettext("\tdestroy [-fnpRrv] <filesystem|volume>\n"
-		    "\tdestroy [-dnpRrv] "
+		return (gettext("\tdestroy [-ifnpRrv] [-T time] <filesystem|volume>\n"
+		    "\tdestroy [-dnpRrv] [-V level] [-a age] [-e prop] [-T time] "
 		    "<filesystem|volume>@<snap>[%<snap>][,...]\n"
 		    "\tdestroy <filesystem|volume>#<bookmark>\n"));
 	case HELP_GET:
@@ -298,8 +298,9 @@
 	case HELP_SHARE:
 		return (gettext("\tshare <-a | filesystem>\n"));
 	case HELP_SNAPSHOT:
-		return (gettext("\tsnapshot|snap [-r] [-o property=value] ... "
-		    "<filesystem|volume>@<snap> ...\n"));
+		return (gettext("\tsnapshot|snap [-n] [-v] [-r] "
+		    "[-m minfree] [-T time] [-o property=value]... "
+		    "... <filesystem|volume>@<snap> ...\n"));
 	case HELP_UNMOUNT:
 		return (gettext("\tunmount|umount [-f] "
 		    "<-a | filesystem|mountpoint>\n"));
@@ -991,12 +992,16 @@
 	boolean_t	cb_doclones;
 	zfs_handle_t	*cb_target;
 	boolean_t	cb_defer_destroy;
-	boolean_t	cb_verbose;
+	int		cb_verbose;
 	boolean_t	cb_parsable;
 	boolean_t	cb_dryrun;
 	nvlist_t	*cb_nvl;
 	nvlist_t	*cb_batchedsnaps;
 
+	time_t          cb_max_age;
+	char            *cb_expires_prop;	
+	boolean_t       cb_skip;
+  
 	/* first snap in contiguous run */
 	char		*cb_firstsnap;
 	/* previous snap in contiguous run */
@@ -1006,6 +1011,17 @@
 	char		*cb_bookmark;
 } destroy_cbdata_t;
 
+
+
+static void
+sigalrm_handler(int sig) {
+	static char msg[] = "\n*** ABORTED DUE TO TIMEOUT ***\n";
+	
+	(void) write(2, msg, sizeof(msg)-1);
+	_exit(1);
+}
+
+
 /*
  * Check for any dependents based on the '-r' or '-R' flags.
  */
@@ -1072,7 +1088,7 @@
 	destroy_cbdata_t *cb = data;
 	const char *name = zfs_get_name(zhp);
 
-	if (cb->cb_verbose) {
+	if (cb->cb_verbose > 2 || cb->cb_parsable) {
 		if (cb->cb_parsable) {
 			(void) printf("destroy\t%s\n", name);
 		} else if (cb->cb_dryrun) {
@@ -1107,7 +1123,13 @@
 	if (zfs_get_type(zhp) == ZFS_TYPE_SNAPSHOT) {
 		fnvlist_add_boolean(cb->cb_batchedsnaps, name);
 	} else {
-		int error = zfs_destroy_snaps_nvl(g_zfs,
+	  	int error;
+		
+	  	if (cb->cb_verbose > 3)
+		  	printf("destroying %ld batched snaps\n",
+			    fnvlist_num_pairs(cb->cb_batchedsnaps));
+		
+		error = zfs_destroy_snaps_nvl(g_zfs,
 		    cb->cb_batchedsnaps, B_FALSE);
 		fnvlist_free(cb->cb_batchedsnaps);
 		cb->cb_batchedsnaps = fnvlist_alloc();
@@ -1131,6 +1153,9 @@
 	const char *name = zfs_get_name(zhp);
 	int err = 0;
 
+	if (zfs_get_type(zhp) == ZFS_TYPE_SNAPSHOT && cb->cb_skip && 0)
+	  goto Out;
+	
 	if (nvlist_exists(cb->cb_nvl, name)) {
 		if (cb->cb_firstsnap == NULL)
 			cb->cb_firstsnap = strdup(name);
@@ -1140,7 +1165,7 @@
 		cb->cb_prevsnap = strdup(name);
 		if (cb->cb_firstsnap == NULL || cb->cb_prevsnap == NULL)
 			nomem();
-		if (cb->cb_verbose) {
+		if (cb->cb_verbose > 2 || cb->cb_parsable) {
 			if (cb->cb_parsable) {
 				(void) printf("destroy\t%s\n", name);
 			} else if (cb->cb_dryrun) {
@@ -1151,7 +1176,12 @@
 				    name);
 			}
 		}
-	} else if (cb->cb_firstsnap != NULL) {
+		zfs_close(zhp);
+		return (err);
+	}
+
+ Out:
+	if (cb->cb_firstsnap != NULL) {
 		/* end of this range */
 		uint64_t used = 0;
 		err = lzc_snaprange_space(cb->cb_firstsnap,
@@ -1194,35 +1224,113 @@
 	destroy_cbdata_t *cb = arg;
 	int err = 0;
 
+	if (zfs_get_type(zhp) == ZFS_TYPE_SNAPSHOT) {
+		if (cb->cb_max_age) {
+			time_t created;
+	    
+			if ((created = zfs_prop_get_int(zhp, ZFS_PROP_CREATION)) >= cb->cb_max_age) {
+				if (cb->cb_verbose > 3)
+					printf(gettext("skipping destroy of '%s'"
+					    ": creation too new (%llu >= %llu)\n"),
+					    zfs_get_name(zhp),
+					    (unsigned long long) created,
+					    (unsigned long long) cb->cb_max_age);
+				cb->cb_skip = 1;
+				zfs_close(zhp);
+				return (0);
+			}
+		}
+	  
+		if (cb->cb_expires_prop) {
+			time_t now, expires;
+			nvlist_t *userprops = zfs_get_user_props(zhp);
+			nvlist_t *propval = NULL;
+			char *strval = NULL;
+			
+			time(&now);
+			(void) nvlist_lookup_nvlist(userprops, cb->cb_expires_prop, &propval);
+			
+			if (!propval || nvlist_lookup_string(propval, ZPROP_VALUE, &strval) != 0) {
+				if (cb->cb_verbose > 3)
+					printf(gettext("skipping destroy of '%s'"
+					    ": expiry property (%s) not set or invalid\n"),
+					    zfs_get_name(zhp),
+					    cb->cb_expires_prop);
+				cb->cb_skip = 1;
+				zfs_close(zhp);
+				return (0);
+			}
+			
+			if (sscanf(strval, "%lu", &expires) == 1 && now < expires) {
+				if (cb->cb_verbose > 3)
+					printf(gettext("skipping destroy of '%s'"
+					    ": not expired (%ld < %ld)\n"),
+					    zfs_get_name(zhp),
+					    now, expires);
+				cb->cb_skip = 1;
+				zfs_close(zhp);
+				return (0);
+			}
+		}
+	}
+	
 	/* Check for clones. */
 	if (!cb->cb_doclones && !cb->cb_defer_destroy) {
 		cb->cb_target = zhp;
 		cb->cb_first = B_TRUE;
 		err = zfs_iter_dependents(zhp, B_TRUE,
 		    destroy_check_dependent, cb);
+		if (err)
+			goto Out;
 	}
+	if (nvlist_add_boolean(cb->cb_nvl, zfs_get_name(zhp)))
+		nomem();
 
-	if (err == 0) {
-		if (nvlist_add_boolean(cb->cb_nvl, zfs_get_name(zhp)))
-			nomem();
-	}
+ Out:
 	zfs_close(zhp);
 	return (err);
 }
 
+static void
+spin(void) {
+  	static int p = 0;
+	static char dials[] = "|/-\\";
+	static time_t last = 0;
+	time_t now;
+	
+	if (isatty(fileno(stderr))) {
+	  	time(&now);
+		if (now != last) {
+		  	putc(dials[p], stderr);
+			putc('\b', stderr);
+			p = (p+1)&3;
+			last = now;
+		}
+	}
+}
+
+
 static int
 gather_snapshots(zfs_handle_t *zhp, void *arg)
 {
 	destroy_cbdata_t *cb = arg;
 	int err = 0;
+	static int ns = 0;
 
+	if (cb->cb_verbose) {
+	  if (cb->cb_verbose > 1)
+	    printf("gathering snapshots at %s [#%d]\n", zfs_get_name(zhp), ++ns);
+	  else
+	    spin();
+	}
+	
 	err = zfs_iter_snapspec(zhp, cb->cb_snapspec, snapshot_to_nvl_cb, cb);
 	if (err == ENOENT)
 		err = 0;
 	if (err != 0)
 		goto out;
 
-	if (cb->cb_verbose) {
+	if (cb->cb_verbose || cb->cb_parsable) {
 		err = destroy_print_snapshots(zhp, cb);
 		if (err != 0)
 			goto out;
@@ -1266,6 +1374,118 @@
 }
 
 static int
+prompt_yesno(const char *fmt,
+	     ...) {
+  va_list ap;
+  char *cp, buf[32];
+
+  
+
+ AGAIN:
+  va_start(ap, fmt);
+  vfprintf(stderr, fmt, ap);
+  va_end(ap);
+  
+  if (fgets(buf, sizeof(buf), stdin) == NULL)
+    return -1;
+
+  for (cp = buf+strlen(buf)-1; cp >= buf && isspace(*cp); --cp)
+    ;
+  *++cp = '\0';
+  for (cp = buf; isspace(*cp); ++cp)
+    ;
+  if (strcasecmp(cp, "yes") == 0)
+    return 1;
+  else if (!*cp || strcasecmp(cp, "no") == 0 || strcasecmp(cp, "n") == 0)
+    return 0;
+
+  goto AGAIN;
+}
+
+static int
+str2time(const char *str,
+	 time_t *t) {
+  char pfx = 0;
+  int rc;
+  time_t now;
+  int t_year, t_mon, t_day, t_hour, t_min, t_sec;
+  struct tm *tp;
+
+  
+  if (!str || !*str)
+    return 0;
+
+  while (isspace(*str))
+    ++str;
+
+  t_year = t_mon = t_day = t_hour = t_min = t_sec = 0;
+  
+  if ((rc = sscanf(str, "%d-%d-%d %d:%d:%d",
+		   &t_year, &t_mon, &t_day, &t_hour, &t_min, &t_sec)) == 6) {
+    /* Absolut date+time */
+    time(&now);
+    tp = localtime(&now);
+    if (!tp)
+      return -1;
+
+    if (t_year >= 1900)
+      tp->tm_year = t_year-1900;
+    else
+      tp->tm_year = t_year+100;
+
+    tp->tm_mon   = t_mon-1;
+    tp->tm_mday = t_day;
+    tp->tm_hour = t_hour;
+    tp->tm_min  = t_min;
+    tp->tm_sec  = t_sec;;
+
+    *t = mktime(tp);
+    if (*t == (time_t) -1)
+      return -1;
+
+    *t -= now;
+    return 1;
+    
+  } else if ((rc = sscanf(str, "%d:%d:%d",
+			  &t_hour, &t_min, &t_sec)) >= 2) {
+    *t = t_sec + (t_min*60) + (t_hour*3600);
+    return 1;
+    
+  } else if ((rc = sscanf(str, "%lu%c", t, &pfx)) >= 1) {
+    /* Offset from now */
+    
+    switch (pfx) {
+    case 's':
+      break;
+    case 'm':
+      *t *= 60;
+      break;
+    case 'h':
+      *t *= 60*60;
+      break;
+    case 'D':
+      *t *= 24*60*60;
+      break;
+    case 'W':
+      *t *= 7*24*60*60;
+      break;
+    case 'M':
+      *t *= 30*24*60*60;
+      break;
+    case 'Y':
+      *t *= 365*24*60*60;
+      break;
+    default:
+      return -1;
+    }
+
+    return 1;
+  }
+
+  return (rc == 0 ? 0 : -1);
+}
+
+static int
 zfs_do_destroy(int argc, char **argv)
 {
 	destroy_cbdata_t cb = { 0 };
@@ -1275,15 +1495,26 @@
 	zfs_handle_t *zhp = NULL;
 	char *at, *pound;
 	zfs_type_t type = ZFS_TYPE_DATASET;
-
+	unsigned long maxage;
+	char pfx;
+	boolean_t f_quack = B_FALSE;
+	boolean_t f_yes = B_FALSE;
+	time_t now, timeout = 0;
+	
+	
 	/* check options */
-	while ((c = getopt(argc, argv, "vpndfrR")) != -1) {
+	while ((c = getopt(argc, argv, "iyvpndfrRV:a:e:T:")) != -1) {
 		switch (c) {
+		case 'i':
+			f_quack = B_TRUE;
+			break;
+		case 'y':
+			f_yes = B_TRUE;
+			break;
 		case 'v':
-			cb.cb_verbose = B_TRUE;
+			cb.cb_verbose = 1;
 			break;
 		case 'p':
-			cb.cb_verbose = B_TRUE;
 			cb.cb_parsable = B_TRUE;
 			break;
 		case 'n':
@@ -1303,6 +1534,35 @@
 			cb.cb_recurse = B_TRUE;
 			cb.cb_doclones = B_TRUE;
 			break;
+		case 'e':
+			cb.cb_expires_prop = strdup(optarg);
+			break;
+		case 'V':
+			if (!optarg || sscanf(optarg, "%d", &cb.cb_verbose) != 1) {
+				(void) fprintf(stderr,
+				    gettext("invalid verbosity level '%s'"), optarg ? optarg : "");
+				goto out;
+			}
+			break;
+		case 'a':
+			if (str2time(optarg, &cb.cb_max_age) < 1) {
+				(void) fprintf(stderr,
+				    gettext("invalid maxage '%s'"), optarg ? optarg : "");
+				goto out;
+			}
+			time(&now);
+			if (cb.cb_max_age < 0)
+			  cb.cb_max_age = now+cb.cb_max_age;
+			else
+			  cb.cb_max_age = now-cb.cb_max_age;
+			break;
+		case 'T':
+			if (str2time(optarg, &timeout) < 1) {
+			  	(void) fprintf(stderr,
+				    gettext("invalid timeout '%s'"), optarg ? optarg : "");
+				goto out;
+			}
+			break;
 		case '?':
 		default:
 			(void) fprintf(stderr, gettext("invalid option '%c'\n"),
@@ -1311,6 +1571,11 @@
 		}
 	}
 
+	if (timeout) {
+	  signal(SIGALRM, sigalrm_handler);
+	  alarm(timeout);
+	}
+	
 	argc -= optind;
 	argv += optind;
 
@@ -1338,24 +1603,34 @@
 			return (1);
 
 		cb.cb_snapspec = at + 1;
+
+		if (cb.cb_verbose == 1)
+		  	printf("gathering snapshots to destroy:\n");
+
 		if (gather_snapshots(zfs_handle_dup(zhp), &cb) != 0 ||
 		    cb.cb_error) {
 			rv = 1;
 			goto out;
 		}
 
+		if (cb.cb_verbose)
+		  	printf("snapshots to destroy: %ld+%ld\n",
+			    fnvlist_num_pairs(cb.cb_nvl),
+			    fnvlist_num_pairs(cb.cb_batchedsnaps));
+		
 		if (nvlist_empty(cb.cb_nvl)) {
-			(void) fprintf(stderr, gettext("could not find any "
-			    "snapshots to destroy; check snapshot names.\n"));
+		  	if (!cb.cb_verbose)
+			  	(void) fprintf(stderr, gettext("could not find any "
+				    "snapshots to destroy; check snapshot names.\n"));
 			rv = 1;
 			goto out;
 		}
 
-		if (cb.cb_verbose) {
+		if (cb.cb_verbose || cb.cb_parsable) {
 			char buf[16];
 			zfs_nicenum(cb.cb_snapused, buf, sizeof (buf));
 			if (cb.cb_parsable) {
-				(void) printf("reclaim\t%llu\n",
+				(void) printf("reclaim\t%ld\n",
 				    cb.cb_snapused);
 			} else if (cb.cb_dryrun) {
 				(void) printf(gettext("would reclaim %s\n"),
@@ -1367,11 +1642,26 @@
 		}
 
 		if (!cb.cb_dryrun) {
+			if (f_quack) {
+			  int rc;
+			  size_t nsnaps = (cb.cb_nvl ? fnvlist_num_pairs(cb.cb_nvl) : -1);
+			  
+			  rc = prompt_yesno("About to destroy %d snapshot%s, continue [no]? ",
+					    nsnaps, nsnaps == 1 ? "" : "s");
+			  if (rc != B_TRUE) {
+			    fprintf(stderr, "*** ABORTED ***\n");
+			    exit(1);
+			  }
+			}
+		      
 			if (cb.cb_doclones) {
 				cb.cb_batchedsnaps = fnvlist_alloc();
 				err = destroy_clones(&cb);
 				if (err == 0) {
-					err = zfs_destroy_snaps_nvl(g_zfs,
+				  	if (cb.cb_verbose > 1)
+					  	printf("destroying %ld batched snaps\n",
+						    fnvlist_num_pairs(cb.cb_batchedsnaps));
+				  	err = zfs_destroy_snaps_nvl(g_zfs,
 					    cb.cb_batchedsnaps, B_FALSE);
 				}
 				if (err != 0) {
@@ -1380,6 +1670,10 @@
 				}
 			}
 			if (err == 0) {
+			  	if (cb.cb_verbose > 1)
+				  	printf("destroying %ld snaps%s\n",
+					    fnvlist_num_pairs(cb.cb_nvl),
+					    cb.cb_defer_destroy ? " (deferred)" : "");
 				err = zfs_destroy_snaps_nvl(g_zfs, cb.cb_nvl,
 				    cb.cb_defer_destroy);
 			}
@@ -1467,6 +1761,20 @@
 			goto out;
 		}
 
+		if (f_quack) {
+		  int rc;
+		  size_t nfs = (cb.cb_nvl ? fnvlist_num_pairs(cb.cb_nvl) : -1);
+		  size_t nsnaps = (cb.cb_batchedsnaps ? fnvlist_num_pairs(cb.cb_batchedsnaps) : -1);
+		  
+		  rc = prompt_yesno("About to destroy %d filesystem%s & %d snapshot%s, continue [no]? ",
+				    nfs, nfs == 1 ? "" : "s",
+				    nsnaps, nsnaps == 1 ? "" : "s");
+		  if (rc != B_TRUE) {
+		    fprintf(stderr, "*** ABORTED ***\n");
+		    exit(1);
+		  }
+		}
+		
 		cb.cb_batchedsnaps = fnvlist_alloc();
 		if (zfs_iter_dependents(zhp, B_FALSE, destroy_callback,
 		    &cb) != 0) {
@@ -1481,6 +1789,10 @@
 		err = destroy_callback(zhp, &cb);
 		zhp = NULL;
 		if (err == 0) {
+		  	if (cb.cb_verbose > 1)
+			  	printf("destroying %ld snaps%s\n",
+				    fnvlist_num_pairs(cb.cb_batchedsnaps),
+				    cb.cb_defer_destroy ? " (deferred)" : "");
 			err = zfs_destroy_snaps_nvl(g_zfs,
 			    cb.cb_batchedsnaps, cb.cb_defer_destroy);
 		}
@@ -3677,6 +3989,9 @@
 	nvlist_t *sd_nvl;
 	boolean_t sd_recursive;
 	const char *sd_snapname;
+	uint64_t sd_min_avail;
+	boolean_t sd_verbose;
+	boolean_t sd_no_update;
 } snap_cbdata_t;
 
 static int
@@ -3686,18 +4001,31 @@
 	char *name;
 	int rv = 0;
 	int error;
-
+	uint64_t avail;
+	time_t created;
+     
 	if (sd->sd_recursive &&
 	    zfs_prop_get_int(zhp, ZFS_PROP_INCONSISTENT) != 0) {
 		zfs_close(zhp);
 		return (0);
 	}
 
-	error = asprintf(&name, "%s@%s", zfs_get_name(zhp), sd->sd_snapname);
-	if (error == -1)
-		nomem();
-	fnvlist_add_boolean(sd->sd_nvl, name);
-	free(name);
+	if (sd->sd_min_avail && (avail = zfs_prop_get_int(zhp, ZFS_PROP_AVAILABLE)) < sd->sd_min_avail) {
+	  if (sd->sd_verbose) {
+	    fprintf(stderr,
+		    gettext("skipping snapshot of '%s'"
+			    ": avail too low (%llu < %llu)\n"),
+		    zfs_get_name(zhp),
+		    (unsigned long long) avail,
+		    (unsigned long long) sd->sd_min_avail);
+	  }
+	} else {
+		error = asprintf(&name, "%s@%s", zfs_get_name(zhp), sd->sd_snapname);
+		if (error == -1)
+			nomem();
+		fnvlist_add_boolean(sd->sd_nvl, name);
+		free(name);
+	}
 
 	if (sd->sd_recursive)
 		rv = zfs_iter_filesystems(zhp, zfs_snapshot_cb, sd);
@@ -3706,7 +4034,7 @@
 }
 
 /*
- * zfs snapshot [-r] [-o prop=value] ... <fs@snap>
+ * zfs snapshot [-v] [-n] [-r] [-m minfree] [-o prop=value] ... <fs@snap>
  *
  * Creates a snapshot with the given name.  While functionally equivalent to
  * 'zfs create', it is a separate command to differentiate intent.
@@ -3719,23 +4047,73 @@
 	nvlist_t *props;
 	snap_cbdata_t sd = { 0 };
 	boolean_t multiple_snaps = B_FALSE;
-
+	char pfx;
+	unsigned long avail = 0;
+	time_t now, timeout = 0;
+	
 	if (nvlist_alloc(&props, NV_UNIQUE_NAME, 0) != 0)
 		nomem();
 	if (nvlist_alloc(&sd.sd_nvl, NV_UNIQUE_NAME, 0) != 0)
 		nomem();
 
+	sd.sd_min_avail = 0;
+	sd.sd_verbose = 0;
+	sd.sd_no_update = 0;
+	
 	/* check options */
-	while ((c = getopt(argc, argv, "ro:")) != -1) {
+	while ((c = getopt(argc, argv, "nvro:m:t:T:")) != -1) {
 		switch (c) {
 		case 'o':
 			if (parseprop(props, optarg) != 0)
 				return (1);
 			break;
+		case 'n':
+			sd.sd_no_update = 1;
+			break;
+		case 'v':
+			sd.sd_verbose = 1;
+			break;
 		case 'r':
 			sd.sd_recursive = B_TRUE;
 			multiple_snaps = B_TRUE;
 			break;
+		case 'm':
+			pfx = 0;
+			if (!optarg ||
+			    sscanf(optarg, "%lu%c",
+			    &avail, &pfx) < 1) {
+				(void) fprintf(stderr,
+				    gettext("invalid minfree '%s'"), optarg);
+				goto usage;
+			}
+			sd.sd_min_avail = avail;
+			switch (toupper(pfx)) {
+			case 'K':
+				sd.sd_min_avail *= 1000;
+				break;
+			case 'M':
+				sd.sd_min_avail *= 1000000;
+				break;
+			case 'G':
+				sd.sd_min_avail *= 1000000000;
+				break;
+			case 'T':
+				sd.sd_min_avail *= 1000000000000;
+				break;
+			default:
+				(void) fprintf(stderr,
+				    gettext("invalid minfree suffix '%s'"),
+				    optarg);
+				goto usage;
+			}
+			break;
+		case 'T':
+			if (str2time(optarg, &timeout) < 1) {
+			  	(void) fprintf(stderr,
+				    gettext("invalid timeout '%s'"), optarg ? optarg : "");
+				goto usage;
+			}
+			break;
 		case '?':
 			(void) fprintf(stderr, gettext("invalid option '%c'\n"),
 			    optopt);
@@ -3743,6 +4121,11 @@
 		}
 	}
 
+	if (timeout) {
+	  signal(SIGALRM, sigalrm_handler);
+	  alarm(timeout);
+	}
+	
 	argc -= optind;
 	argv += optind;
 
@@ -3771,7 +4154,10 @@
 			goto usage;
 	}
 
-	ret = zfs_snapshot_nvl(g_zfs, sd.sd_nvl, props);
+	ret = 0;
+	if (!sd.sd_no_update && !nvlist_empty(sd.sd_nvl))
+		ret = zfs_snapshot_nvl(g_zfs, sd.sd_nvl, props);
+
 	nvlist_free(sd.sd_nvl);
 	nvlist_free(props);
 	if (ret != 0 && multiple_snaps)
