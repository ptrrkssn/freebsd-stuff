--- cddl/contrib/opensolaris/cmd/zfs/zfs_main.c.RELEASE	2020-02-29 22:21:01.102091000 +0100
+++ cddl/contrib/opensolaris/cmd/zfs/zfs_main.c	2020-03-18 23:54:23.491159000 +0100
@@ -243,8 +243,8 @@
 		    "\tcreate [-ps] [-b blocksize] [-o property=value] ... "
 		    "-V <size> <volume>\n"));
 	case HELP_DESTROY:
-		return (gettext("\tdestroy [-fnpRrv] <filesystem|volume>\n"
-		    "\tdestroy [-dnpRrv] "
+		return (gettext("\tdestroy [-ifnpRrv] [-T time] <filesystem|volume>\n"
+		    "\tdestroy [-idnpRrv] [-V level] [-a age] [-e prop] [-T time] "
 		    "<filesystem|volume>@<snap>[%<snap>][,...]\n"
 		    "\tdestroy <filesystem|volume>#<bookmark>\n"));
 	case HELP_GET:
@@ -298,8 +298,9 @@
 	case HELP_SHARE:
 		return (gettext("\tshare <-a | filesystem>\n"));
 	case HELP_SNAPSHOT:
-		return (gettext("\tsnapshot|snap [-r] [-o property=value] ... "
-		    "<filesystem|volume>@<snap> ...\n"));
+		return (gettext("\tsnapshot|snap [-n] [-v] [-r] "
+		    "[-m minfree] [-o property=value]... "
+		    "... <filesystem|volume>@<snap> ...\n"));
 	case HELP_UNMOUNT:
 		return (gettext("\tunmount|umount [-f] "
 		    "<-a | filesystem|mountpoint>\n"));
@@ -991,12 +992,17 @@
 	boolean_t	cb_doclones;
 	zfs_handle_t	*cb_target;
 	boolean_t	cb_defer_destroy;
-	boolean_t	cb_verbose;
+	int		cb_verbose;
 	boolean_t	cb_parsable;
 	boolean_t	cb_dryrun;
 	nvlist_t	*cb_nvl;
 	nvlist_t	*cb_batchedsnaps;
 
+	time_t          cb_max_age;
+	time_t          cb_timeout;
+	char            *cb_expires_prop;	
+	boolean_t       cb_skip;
+  
 	/* first snap in contiguous run */
 	char		*cb_firstsnap;
 	/* previous snap in contiguous run */
@@ -1072,7 +1078,7 @@
 	destroy_cbdata_t *cb = data;
 	const char *name = zfs_get_name(zhp);
 
-	if (cb->cb_verbose) {
+	if (cb->cb_verbose > 2 || cb->cb_parsable) {
 		if (cb->cb_parsable) {
 			(void) printf("destroy\t%s\n", name);
 		} else if (cb->cb_dryrun) {
@@ -1107,7 +1113,13 @@
 	if (zfs_get_type(zhp) == ZFS_TYPE_SNAPSHOT) {
 		fnvlist_add_boolean(cb->cb_batchedsnaps, name);
 	} else {
-		int error = zfs_destroy_snaps_nvl(g_zfs,
+	  	int error;
+		
+	  	if (cb->cb_verbose > 3)
+		  	fprintf(stderr, "destroy_callback: destroying %ld batched snaps\n",
+			    fnvlist_num_pairs(cb->cb_batchedsnaps));
+		
+		error = zfs_destroy_snaps_nvl(g_zfs,
 		    cb->cb_batchedsnaps, B_FALSE);
 		fnvlist_free(cb->cb_batchedsnaps);
 		cb->cb_batchedsnaps = fnvlist_alloc();
@@ -1131,6 +1143,9 @@
 	const char *name = zfs_get_name(zhp);
 	int err = 0;
 
+	if (zfs_get_type(zhp) == ZFS_TYPE_SNAPSHOT && cb->cb_skip && 0)
+	  goto Out;
+	
 	if (nvlist_exists(cb->cb_nvl, name)) {
 		if (cb->cb_firstsnap == NULL)
 			cb->cb_firstsnap = strdup(name);
@@ -1140,7 +1155,7 @@
 		cb->cb_prevsnap = strdup(name);
 		if (cb->cb_firstsnap == NULL || cb->cb_prevsnap == NULL)
 			nomem();
-		if (cb->cb_verbose) {
+		if (cb->cb_verbose > 2 || cb->cb_parsable) {
 			if (cb->cb_parsable) {
 				(void) printf("destroy\t%s\n", name);
 			} else if (cb->cb_dryrun) {
@@ -1151,7 +1166,12 @@
 				    name);
 			}
 		}
-	} else if (cb->cb_firstsnap != NULL) {
+		zfs_close(zhp);
+		return (err);
+	}
+
+ Out:
+	if (cb->cb_firstsnap != NULL) {
 		/* end of this range */
 		uint64_t used = 0;
 		err = lzc_snaprange_space(cb->cb_firstsnap,
@@ -1194,35 +1214,117 @@
 	destroy_cbdata_t *cb = arg;
 	int err = 0;
 
+	if (zfs_get_type(zhp) == ZFS_TYPE_SNAPSHOT) {
+	  if (cb->cb_max_age) {
+	    time_t created;
+	    
+	    if ((created = zfs_prop_get_int(zhp, ZFS_PROP_CREATION)) >= cb->cb_max_age) {
+	      if (cb->cb_verbose > 3)
+		fprintf(stderr,
+			gettext("skipping destroy of '%s'"
+				": creation too new (%llu >= %llu)\n"),
+			zfs_get_name(zhp),
+			(unsigned long long) created,
+			(unsigned long long) cb->cb_max_age);
+	      cb->cb_skip = 1;
+	      zfs_close(zhp);
+	      return (0);
+	    }
+	  }
+	  
+	  if (cb->cb_expires_prop) {
+	    time_t now, expires;
+	    nvlist_t *userprops = zfs_get_user_props(zhp);
+	    nvlist_t *propval = NULL;
+	    char *strval = NULL;
+
+	    time(&now);
+	    (void) nvlist_lookup_nvlist(userprops, cb->cb_expires_prop, &propval);
+	    
+	    if (!propval || nvlist_lookup_string(propval, ZPROP_VALUE, &strval) != 0) {
+	      if (cb->cb_verbose > 3)
+		fprintf(stderr,
+			gettext("skipping destroy of '%s': expiry property (%s) not set or invalid\n"),
+			zfs_get_name(zhp),
+			cb->cb_expires_prop);
+	      cb->cb_skip = 1;
+	      zfs_close(zhp);
+	      return (0);
+	    }
+	    
+	    if (sscanf(strval, "%lu", &expires) == 1 && now < expires) {
+	      if (cb->cb_verbose > 3)
+		fprintf(stderr,
+			gettext("skipping destroy of '%s': not expired (%ld < %ld)\n"),
+			zfs_get_name(zhp),
+			now, expires);
+	      cb->cb_skip = 1;
+	      zfs_close(zhp);
+	      return (0);
+	    }
+	  }
+	}
+	
 	/* Check for clones. */
 	if (!cb->cb_doclones && !cb->cb_defer_destroy) {
 		cb->cb_target = zhp;
 		cb->cb_first = B_TRUE;
 		err = zfs_iter_dependents(zhp, B_TRUE,
 		    destroy_check_dependent, cb);
+		if (err)
+			goto Out;
 	}
+#if 0
+	fprintf(stderr, "Adding %s to cb->cb_nvl\n", zfs_get_name(zhp));
+#endif	
+	if (nvlist_add_boolean(cb->cb_nvl, zfs_get_name(zhp)))
+		nomem();
 
-	if (err == 0) {
-		if (nvlist_add_boolean(cb->cb_nvl, zfs_get_name(zhp)))
-			nomem();
-	}
+ Out:
 	zfs_close(zhp);
 	return (err);
 }
 
+static void
+spin(void) {
+  static int p = 0;
+  static char dials[] = "|/-\\";
+  static time_t last = 0;
+  time_t now;
+
+  if (isatty(fileno(stderr))) {
+    time(&now);
+    if (now != last) {
+      putc(dials[p], stderr);
+      putc('\b', stderr);
+      p = (p+1)&3;
+      last = now;
+    }
+  }
+}
+
+
 static int
 gather_snapshots(zfs_handle_t *zhp, void *arg)
 {
 	destroy_cbdata_t *cb = arg;
 	int err = 0;
+	static int ns = 0;
 
+	if (cb->cb_verbose) {
+	  if (cb->cb_verbose > 1)
+	    fprintf(stderr, "gathering snapshots at %s [#%d]\n", zfs_get_name(zhp), ++ns);
+	  else
+	    spin();
+	}
+	
 	err = zfs_iter_snapspec(zhp, cb->cb_snapspec, snapshot_to_nvl_cb, cb);
 	if (err == ENOENT)
 		err = 0;
 	if (err != 0)
 		goto out;
 
-	if (cb->cb_verbose) {
+	if (cb->cb_verbose || cb->cb_parsable) {
 		err = destroy_print_snapshots(zhp, cb);
 		if (err != 0)
 			goto out;
@@ -1266,6 +1368,88 @@
 }
 
 static int
+prompt_yesno(const char *fmt,
+	     ...) {
+  va_list ap;
+  char *cp, buf[32];
+
+  
+
+ AGAIN:
+  va_start(ap, fmt);
+  vfprintf(stderr, fmt, ap);
+  va_end(ap);
+  
+  if (fgets(buf, sizeof(buf), stdin) == NULL)
+    return -1;
+
+  for (cp = buf+strlen(buf)-1; cp >= buf && isspace(*cp); --cp)
+    ;
+  *++cp = '\0';
+  for (cp = buf; isspace(*cp); ++cp)
+    ;
+  if (strcasecmp(cp, "yes") == 0)
+    return 1;
+  else if (!*cp || strcasecmp(cp, "no") == 0 || strcasecmp(cp, "n") == 0)
+    return 0;
+
+  goto AGAIN;
+}
+
+static int
+str2time(const char *str,
+	 time_t *t) {
+  char pfx = 0;
+  int rc;
+  
+
+  if (!str || !*str)
+    return 0;
+
+  while (isspace(*str))
+    ++str;
+  
+  rc = sscanf(str, "%lu%c", t, &pfx);
+  if (rc < 1)
+    return rc;
+  
+  switch (pfx) {
+  case 's':
+    break;
+  case 'm':
+    *t *= 60;
+    break;
+  case 'h':
+    *t *= 60*60;
+    break;
+  case 'D':
+    *t *= 24*60*60;
+    break;
+  case 'W':
+    *t *= 7*24*60*60;
+    break;
+  case 'M':
+    *t *= 30*24*60*60;
+    break;
+  case 'Y':
+    *t *= 365*24*60*60;
+    break;
+  default:
+    return -1;
+  }
+
+  return 1;
+}
+
+static void
+sigalrm_handler(int sig) {
+	static char *msg = "\n*** TIMEOUT ***\n";
+	
+	write(2, msg, sizeof(msg)-1);
+	_exit(1);
+}
+
+static int
 zfs_do_destroy(int argc, char **argv)
 {
 	destroy_cbdata_t cb = { 0 };
@@ -1275,15 +1459,26 @@
 	zfs_handle_t *zhp = NULL;
 	char *at, *pound;
 	zfs_type_t type = ZFS_TYPE_DATASET;
-
+	unsigned long maxage;
+	char pfx;
+	time_t now;
+	boolean_t f_quack = B_FALSE;
+	boolean_t f_yes = B_FALSE;
+	
+	
 	/* check options */
-	while ((c = getopt(argc, argv, "vpndfrR")) != -1) {
+	while ((c = getopt(argc, argv, "iyvpndfrRV:a:e:T:")) != -1) {
 		switch (c) {
+		case 'i':
+			f_quack = B_TRUE;
+			break;
+		case 'y':
+			f_yes = B_TRUE;
+			break;
 		case 'v':
-			cb.cb_verbose = B_TRUE;
+			cb.cb_verbose = 1;
 			break;
 		case 'p':
-			cb.cb_verbose = B_TRUE;
 			cb.cb_parsable = B_TRUE;
 			break;
 		case 'n':
@@ -1303,6 +1498,34 @@
 			cb.cb_recurse = B_TRUE;
 			cb.cb_doclones = B_TRUE;
 			break;
+		case 'e':
+			cb.cb_expires_prop = strdup(optarg);
+			break;
+		case 'V':
+			if (!optarg || sscanf(optarg, "%d", &cb.cb_verbose) != 1) {
+				(void) fprintf(stderr,
+				    gettext("invalid verbosity level '%s'"), optarg ? optarg : "");
+				goto out;
+			}
+			break;
+		case 'a':
+			if (str2time(optarg, &cb.cb_max_age) < 1) {
+				(void) fprintf(stderr,
+				    gettext("invalid maxage '%s'"), optarg ? optarg : "");
+				goto out;
+			}
+			time(&now);
+			cb.cb_max_age = now-cb.cb_max_age;
+			break;
+		case 'T':
+			if (str2time(optarg, &cb.cb_timeout) < 1) {
+				(void) fprintf(stderr,
+				    gettext("invalid timeout '%s'"), optarg ? optarg : "");
+				goto out;
+			}
+			time(&now);
+			cb.cb_timeout;
+			break;
 		case '?':
 		default:
 			(void) fprintf(stderr, gettext("invalid option '%c'\n"),
@@ -1311,6 +1534,11 @@
 		}
 	}
 
+	if (cb.cb_timeout) {
+	  signal(SIGALRM, sigalrm_handler);
+	  alarm(cb.cb_timeout);
+	}
+	
 	argc -= optind;
 	argv += optind;
 
@@ -1338,12 +1566,20 @@
 			return (1);
 
 		cb.cb_snapspec = at + 1;
+
+		if (cb.cb_verbose == 1)
+		  fprintf(stderr, "gathering snapshots to destroy:\n");
 		if (gather_snapshots(zfs_handle_dup(zhp), &cb) != 0 ||
 		    cb.cb_error) {
 			rv = 1;
 			goto out;
 		}
 
+		if (cb.cb_verbose)
+		  	fprintf(stderr, "snapshots to destroy: %ld+%ld\n",
+				fnvlist_num_pairs(cb.cb_nvl),
+				fnvlist_num_pairs(cb.cb_batchedsnaps));
+		
 		if (nvlist_empty(cb.cb_nvl)) {
 			(void) fprintf(stderr, gettext("could not find any "
 			    "snapshots to destroy; check snapshot names.\n"));
@@ -1351,11 +1587,11 @@
 			goto out;
 		}
 
-		if (cb.cb_verbose) {
+		if (cb.cb_verbose || cb.cb_parsable) {
 			char buf[16];
 			zfs_nicenum(cb.cb_snapused, buf, sizeof (buf));
 			if (cb.cb_parsable) {
-				(void) printf("reclaim\t%llu\n",
+				(void) printf("reclaim\t%ld\n",
 				    cb.cb_snapused);
 			} else if (cb.cb_dryrun) {
 				(void) printf(gettext("would reclaim %s\n"),
@@ -1367,11 +1603,26 @@
 		}
 
 		if (!cb.cb_dryrun) {
+			if (f_quack) {
+			  int rc;
+			  size_t nsnaps = (cb.cb_nvl ? fnvlist_num_pairs(cb.cb_nvl) : -1);
+			  
+			  rc = prompt_yesno("About to destroy %d snapshot%s, continue [no]? ",
+					    nsnaps, nsnaps == 1 ? "" : "s");
+			  if (rc != B_TRUE) {
+			    fprintf(stderr, "*** Aborted ***\n");
+			    exit(1);
+			  }
+			}
+		      
 			if (cb.cb_doclones) {
 				cb.cb_batchedsnaps = fnvlist_alloc();
 				err = destroy_clones(&cb);
 				if (err == 0) {
-					err = zfs_destroy_snaps_nvl(g_zfs,
+				  	if (cb.cb_verbose > 1)
+					  	fprintf(stderr, "zfs_do_destroy: destroying %ld batched snaps\n",
+						    fnvlist_num_pairs(cb.cb_batchedsnaps));
+				  	err = zfs_destroy_snaps_nvl(g_zfs,
 					    cb.cb_batchedsnaps, B_FALSE);
 				}
 				if (err != 0) {
@@ -1380,6 +1631,10 @@
 				}
 			}
 			if (err == 0) {
+			  	if (cb.cb_verbose > 1)
+				  	fprintf(stderr, "zfs_do_destroy: destroying %ld snaps%s\n",
+					    fnvlist_num_pairs(cb.cb_nvl),
+					    cb.cb_defer_destroy ? " (deferred)" : "");
 				err = zfs_destroy_snaps_nvl(g_zfs, cb.cb_nvl,
 				    cb.cb_defer_destroy);
 			}
@@ -1467,6 +1722,20 @@
 			goto out;
 		}
 
+		if (f_quack) {
+		  int rc;
+		  size_t nfs = (cb.cb_nvl ? fnvlist_num_pairs(cb.cb_nvl) : -1);
+		  size_t nsnaps = (cb.cb_batchedsnaps ? fnvlist_num_pairs(cb.cb_batchedsnaps) : -1);
+		  
+		  rc = prompt_yesno("About to destroy %d filesystem%s & %d snapshot%s, continue [no]? ",
+				    nfs, nfs == 1 ? "" : "s",
+				    nsnaps, nsnaps == 1 ? "" : "s");
+		  if (rc != B_TRUE) {
+		    fprintf(stderr, "*** Aborted ***\n");
+		    exit(1);
+		  }
+		}
+		
 		cb.cb_batchedsnaps = fnvlist_alloc();
 		if (zfs_iter_dependents(zhp, B_FALSE, destroy_callback,
 		    &cb) != 0) {
@@ -1481,6 +1750,10 @@
 		err = destroy_callback(zhp, &cb);
 		zhp = NULL;
 		if (err == 0) {
+		  	if (cb.cb_verbose > 1)
+			  	fprintf(stderr, "zfs_do_destroy: destroying %ld snaps%s\n",
+				    fnvlist_num_pairs(cb.cb_batchedsnaps),
+				    cb.cb_defer_destroy ? " (deferred)" : "");
 			err = zfs_destroy_snaps_nvl(g_zfs,
 			    cb.cb_batchedsnaps, cb.cb_defer_destroy);
 		}
@@ -3677,6 +3950,9 @@
 	nvlist_t *sd_nvl;
 	boolean_t sd_recursive;
 	const char *sd_snapname;
+	uint64_t sd_min_avail;
+	boolean_t sd_verbose;
+	boolean_t sd_no_update;
 } snap_cbdata_t;
 
 static int
@@ -3686,18 +3962,31 @@
 	char *name;
 	int rv = 0;
 	int error;
-
+	uint64_t avail;
+	time_t created;
+     
 	if (sd->sd_recursive &&
 	    zfs_prop_get_int(zhp, ZFS_PROP_INCONSISTENT) != 0) {
 		zfs_close(zhp);
 		return (0);
 	}
 
-	error = asprintf(&name, "%s@%s", zfs_get_name(zhp), sd->sd_snapname);
-	if (error == -1)
-		nomem();
-	fnvlist_add_boolean(sd->sd_nvl, name);
-	free(name);
+	if (sd->sd_min_avail && (avail = zfs_prop_get_int(zhp, ZFS_PROP_AVAILABLE)) < sd->sd_min_avail) {
+	  if (sd->sd_verbose) {
+	    fprintf(stderr,
+		    gettext("skipping snapshot of '%s'"
+			    ": avail too low (%llu < %llu)\n"),
+		    zfs_get_name(zhp),
+		    (unsigned long long) avail,
+		    (unsigned long long) sd->sd_min_avail);
+	  }
+	} else {
+		error = asprintf(&name, "%s@%s", zfs_get_name(zhp), sd->sd_snapname);
+		if (error == -1)
+			nomem();
+		fnvlist_add_boolean(sd->sd_nvl, name);
+		free(name);
+	}
 
 	if (sd->sd_recursive)
 		rv = zfs_iter_filesystems(zhp, zfs_snapshot_cb, sd);
@@ -3706,7 +3995,7 @@
 }
 
 /*
- * zfs snapshot [-r] [-o prop=value] ... <fs@snap>
+ * zfs snapshot [-v] [-n] [-r] [-m minfree] [-o prop=value] ... <fs@snap>
  *
  * Creates a snapshot with the given name.  While functionally equivalent to
  * 'zfs create', it is a separate command to differentiate intent.
@@ -3719,23 +4008,65 @@
 	nvlist_t *props;
 	snap_cbdata_t sd = { 0 };
 	boolean_t multiple_snaps = B_FALSE;
-
+	char pfx;
+	unsigned long avail = 0;
+	
 	if (nvlist_alloc(&props, NV_UNIQUE_NAME, 0) != 0)
 		nomem();
 	if (nvlist_alloc(&sd.sd_nvl, NV_UNIQUE_NAME, 0) != 0)
 		nomem();
 
+	sd.sd_min_avail = 0;
+	sd.sd_verbose = 0;
+	sd.sd_no_update = 0;
+	
 	/* check options */
-	while ((c = getopt(argc, argv, "ro:")) != -1) {
+	while ((c = getopt(argc, argv, "nvro:m:t:")) != -1) {
 		switch (c) {
 		case 'o':
 			if (parseprop(props, optarg) != 0)
 				return (1);
 			break;
+		case 'n':
+			sd.sd_no_update = 1;
+			break;
+		case 'v':
+			sd.sd_verbose = 1;
+			break;
 		case 'r':
 			sd.sd_recursive = B_TRUE;
 			multiple_snaps = B_TRUE;
 			break;
+		case 'm':
+			pfx = 0;
+			if (!optarg ||
+			    sscanf(optarg, "%lu%c",
+			    &avail, &pfx) < 1) {
+				(void) fprintf(stderr,
+				    gettext("invalid minfree '%s'"), optarg);
+				goto usage;
+			}
+			sd.sd_min_avail = avail;
+			switch (toupper(pfx)) {
+			case 'K':
+				sd.sd_min_avail *= 1000;
+				break;
+			case 'M':
+				sd.sd_min_avail *= 1000000;
+				break;
+			case 'G':
+				sd.sd_min_avail *= 1000000000;
+				break;
+			case 'T':
+				sd.sd_min_avail *= 1000000000000;
+				break;
+			default:
+				(void) fprintf(stderr,
+				    gettext("invalid minfree suffix '%s'"),
+				    optarg);
+				goto usage;
+			}
+			break;
 		case '?':
 			(void) fprintf(stderr, gettext("invalid option '%c'\n"),
 			    optopt);
@@ -3771,7 +4102,10 @@
 			goto usage;
 	}
 
-	ret = zfs_snapshot_nvl(g_zfs, sd.sd_nvl, props);
+	ret = 0;
+	if (!sd.sd_no_update && !nvlist_empty(sd.sd_nvl))
+		ret = zfs_snapshot_nvl(g_zfs, sd.sd_nvl, props);
+
 	nvlist_free(sd.sd_nvl);
 	nvlist_free(props);
 	if (ret != 0 && multiple_snaps)
